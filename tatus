[1mdiff --git a/app/components/Accordion.tsx b/app/components/Accordion.tsx[m
[1mindex 3f106e9..3c1e994 100644[m
[1m--- a/app/components/Accordion.tsx[m
[1m+++ b/app/components/Accordion.tsx[m
[36m@@ -86,7 +86,40 @@[m [mexport const Accordion: React.FC<AccordionProps> = ({[m
           JSON.stringify(activeItems),[m
         );[m
       } catch (error) {[m
[31m-        console.warn("Failed to save accordion state to localStorage", error);[m
[32m+[m[32m        if (error instanceof DOMException) {[m
[32m+[m[32m          if (error.name === 'QuotaExceededError') {[m
[32m+[m[32m            // Clear old accordion states to make room[m
[32m+[m[32m            try {[m
[32m+[m[32m              const allKeys = Object.keys(localStorage);[m
[32m+[m[32m              const accordionKeys = allKeys[m
[32m+[m[32m                .filter(key => key.startsWith('accordion-'))[m
[32m+[m[32m                .sort();[m
[32m+[m[41m              [m
[32m+[m[32m              // Remove oldest states, keep 5 most recent[m
[32m+[m[32m              accordionKeys.slice(0, Math.max(0, accordionKeys.length - 5))[m
[32m+[m[32m                .forEach(key => {[m
[32m+[m[32m                  try {[m
[32m+[m[32m                    localStorage.removeItem(key);[m
[32m+[m[32m                  } catch (e) {[m
[32m+[m[32m                    // Ignore cleanup errors[m
[32m+[m[32m                  }[m
[32m+[m[32m                });[m
[32m+[m[41m              [m
[32m+[m[32m              // Retry save[m
[32m+[m[32m              localStorage.setItem([m
[32m+[m[32m                `accordion-${persistKey}`,[m
[32m+[m[32m                JSON.stringify(activeItems),[m
[32m+[m[32m              );[m
[32m+[m[32m            } catch (retryError) {[m
[32m+[m[32m              console.warn("Could not persist accordion state", retryError);[m
[32m+[m[32m            }[m
[32m+[m[32m          } else if (error.name === 'SecurityError') {[m
[32m+[m[32m            // Private browsing mode - silently fail[m
[32m+[m[32m            console.info('localStorage unavailable (private browsing?)');[m
[32m+[m[32m          }[m
[32m+[m[32m        } else {[m
[32m+[m[32m          console.warn("Failed to save accordion state", error);[m
[32m+[m[32m        }[m
       }[m
     }[m
   }, [activeItems, persistKey]);[m
[1mdiff --git a/app/components/ResumeCard.tsx b/app/components/ResumeCard.tsx[m
[1mindex 1cfb70c..128996e 100644[m
[1m--- a/app/components/ResumeCard.tsx[m
[1m+++ b/app/components/ResumeCard.tsx[m
[36m@@ -1,9 +1,10 @@[m
 ï»¿import { Link } from "react-router";[m
 import ScoreCircle from "./ScoreCircle";[m
[31m-import { useEffect, useMemo, useState } from "react";[m
[32m+[m[32mimport { useEffect, useMemo, useState, useRef } from "react";[m
 import { usePuterStore } from "~/lib/puter";[m
[32m+[m[32mimport React from "react";[m
 [m
[31m-const ResumeCard = ({[m
[32m+[m[32mconst ResumeCard = React.memo(({[m
   resume: { id, companyName, jobTitle, feedback, imagePath },[m
   onDelete,[m
 }: {[m
[36m@@ -12,6 +13,8 @@[m [mconst ResumeCard = ({[m
 }) => {[m
   const { fs } = usePuterStore();[m
   const [resumeUrl, setResumeUrl] = useState<string | null>(null);[m
[32m+[m[32m  const [isVisible, setIsVisible] = useState(false);[m
[32m+[m[32m  const cardRef = useRef<HTMLDivElement>(null);[m
 [m
   const hasFeedback = typeof feedback === "object" && feedback !== null;[m
 [m
[36m@@ -28,21 +31,74 @@[m [mconst ResumeCard = ({[m
     ];[m
 [m
     return pairs.sort((a, b) => b.score - a.score).slice(0, 2);[m
[31m-  }, [hasFeedback, feedback]);[m
[32m+[m[32m  }, [[m
[32m+[m[32m    hasFeedback,[m
[32m+[m[32m    feedback?.toneAndStyle?.score,[m
[32m+[m[32m    feedback?.content?.score,[m
[32m+[m[32m    feedback?.structure?.score,[m
[32m+[m[32m    feedback?.skills?.score,[m
[32m+[m[32m  ]);[m
 [m
[32m+[m[32m  // Intersection observer for lazy loading[m
   useEffect(() => {[m
[32m+[m[32m    // Feature detection - load immediately if not supported[m
[32m+[m[32m    if (typeof window === 'undefined' || !('IntersectionObserver' in window)) {[m
[32m+[m[32m      setIsVisible(true);[m
[32m+[m[32m      return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    const observer = new IntersectionObserver([m
[32m+[m[32m      ([entry]) => {[m
[32m+[m[32m        if (entry.isIntersecting) {[m
[32m+[m[32m          setIsVisible(true);[m
[32m+[m[32m          observer.disconnect();[m
[32m+[m[32m        }[m
[32m+[m[32m      },[m
[32m+[m[32m      {[m
[32m+[m[32m        rootMargin: '50px', // Start loading 50px before entering viewport[m
[32m+[m[32m      }[m
[32m+[m[32m    );[m
[32m+[m
[32m+[m[32m    if (cardRef.current) {[m
[32m+[m[32m      observer.observe(cardRef.current);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return () => observer.disconnect();[m
[32m+[m[32m  }, []);[m
[32m+[m
[32m+[m[32m  // Load image only when visible[m
[32m+[m[32m  useEffect(() => {[m
[32m+[m[32m    if (!isVisible) return;[m
[32m+[m
     const loadResume = async () => {[m
[31m-      const blob = await fs.read(imagePath);[m
[31m-      if (!blob) return;[m
[31m-      const url = URL.createObjectURL(blob);[m
[31m-      setResumeUrl(url);[m
[32m+[m[32m      try {[m
[32m+[m[32m        const blob = await fs.read(imagePath);[m
[32m+[m[32m        if (!blob) return;[m
[32m+[m[32m        const url = URL.createObjectURL(blob);[m
[32m+[m[32m        setResumeUrl(url);[m
[32m+[m[32m      } catch (error) {[m
[32m+[m[32m        console.error('Failed to load resume image:', error);[m
[32m+[m[32m      }[m
     };[m
 [m
     loadResume();[m
[31m-  }, [imagePath]);[m
[32m+[m[32m  }, [isVisible, imagePath, fs]);[m
[32m+[m
[32m+[m[32m  // Cleanup URL on unmount[m
[32m+[m[32m  useEffect(() => {[m
[32m+[m[32m    return () => {[m
[32m+[m[32m      if (resumeUrl) {[m
[32m+[m[32m        try {[m
[32m+[m[32m          URL.revokeObjectURL(resumeUrl);[m
[32m+[m[32m        } catch (e) {[m
[32m+[m[32m          // Ignore errors from already-revoked URLs[m
[32m+[m[32m        }[m
[32m+[m[32m      }[m
[32m+[m[32m    };[m
[32m+[m[32m  }, [resumeUrl]);[m
 [m
   return ([m
[31m-    <div className="relative">[m
[32m+[m[32m    <div ref={cardRef} className="relative">[m
       {onDelete && ([m
         <button[m
           onClick={(e) => {[m
[36m@@ -155,6 +211,18 @@[m [mconst ResumeCard = ({[m
       </Link>[m
     </div>[m
   );[m
[31m-};[m
[32m+[m[32m}, (prevProps, nextProps) => {[m
[32m+[m[32m  // Return true if props are equal (skip re-render)[m
[32m+[m[32m  return ([m
[32m+[m[32m    prevProps.resume.id === nextProps.resume.id &&[m
[32m+[m[32m    prevProps.resume.imagePath === nextProps.resume.imagePath &&[m
[32m+[m[32m    prevProps.resume.companyName === nextProps.resume.companyName &&[m
[32m+[m[32m    prevProps.resume.jobTitle === nextProps.resume.jobTitle &&[m
[32m+[m[32m    prevProps.resume.feedback?.overallScore === nextProps.resume.feedback?.overallScore &&[m
[32m+[m[32m    prevProps.onDelete === nextProps.onDelete[m
[32m+[m[32m  );[m
[32m+[m[32m});[m
[32m+[m
[32m+[m[32mResumeCard.displayName = 'ResumeCard';[m
 [m
 export default ResumeCard;[m
[1mdiff --git a/app/lib/pdf2img.ts b/app/lib/pdf2img.ts[m
[1mindex c5578ab..d2abc2c 100644[m
[1m--- a/app/lib/pdf2img.ts[m
[1m+++ b/app/lib/pdf2img.ts[m
[36m@@ -7,6 +7,7 @@[m [mexport interface PdfConversionResult {[m
 let pdfjsLib: any = null;[m
 let isLoading = false;[m
 let loadPromise: Promise<any> | null = null;[m
[32m+[m[32mlet workerInstance: Worker | null = null;[m
 [m
 async function loadPdfJs(): Promise<any> {[m
   if (pdfjsLib) return pdfjsLib;[m
[36m@@ -18,11 +19,16 @@[m [masync function loadPdfJs(): Promise<any> {[m
     if (typeof window === "undefined") {[m
       throw new Error("PDF rendering is only available in the browser");[m
     }[m
[31m-    const worker = new Worker([m
[31m-      new URL("pdfjs-dist/build/pdf.worker.mjs", import.meta.url),[m
[31m-      { type: "module" },[m
[31m-    );[m
[31m-    lib.GlobalWorkerOptions.workerPort = worker;[m
[32m+[m[41m    [m
[32m+[m[32m    // Reuse existing worker or create new[m
[32m+[m[32m    if (!workerInstance) {[m
[32m+[m[32m      workerInstance = new Worker([m
[32m+[m[32m        new URL("pdfjs-dist/build/pdf.worker.mjs", import.meta.url),[m
[32m+[m[32m        { type: "module" },[m
[32m+[m[32m      );[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    lib.GlobalWorkerOptions.workerPort = workerInstance;[m
     pdfjsLib = lib;[m
     isLoading = false;[m
     return lib;[m
[36m@@ -31,9 +37,20 @@[m [masync function loadPdfJs(): Promise<any> {[m
   return loadPromise;[m
 }[m
 [m
[32m+[m[32m// Export cleanup function for worker termination[m
[32m+[m[32mexport function terminatePdfWorker() {[m
[32m+[m[32m  if (workerInstance) {[m
[32m+[m[32m    workerInstance.terminate();[m
[32m+[m[32m    workerInstance = null;[m
[32m+[m[32m    pdfjsLib = null;[m
[32m+[m[32m    loadPromise = null;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
 export async function convertPdfToImage([m
   file: File,[m
 ): Promise<PdfConversionResult> {[m
[32m+[m[32m  const startTime = performance.now();[m
   try {[m
     const lib = await loadPdfJs();[m
 [m
[36m@@ -41,7 +58,8 @@[m [mexport async function convertPdfToImage([m
     const pdf = await lib.getDocument({ data: arrayBuffer }).promise;[m
     const page = await pdf.getPage(1);[m
 [m
[31m-    const viewport = page.getViewport({ scale: 4 });[m
[32m+[m[32m    // Reduced scale from 4 to 2 for better performance (4x less memory)[m
[32m+[m[32m    const viewport = page.getViewport({ scale: 2 });[m
     const canvas = document.createElement("canvas");[m
     const context = canvas.getContext("2d");[m
 [m
[36m@@ -56,15 +74,28 @@[m [mexport async function convertPdfToImage([m
     await page.render({ canvasContext: context!, viewport }).promise;[m
 [m
     return new Promise((resolve) => {[m
[32m+[m[32m      // Try WebP first, fallback to PNG[m
[32m+[m[32m      const testCanvas = document.createElement('canvas');[m
[32m+[m[32m      testCanvas.width = 1;[m
[32m+[m[32m      testCanvas.height = 1;[m
[32m+[m[32m      const supportsWebP = testCanvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;[m
[32m+[m[41m      [m
[32m+[m[32m      const format = supportsWebP ? 'image/webp' : 'image/png';[m
[32m+[m[32m      const quality = supportsWebP ? 0.9 : 1.0;[m
[32m+[m[41m      [m
       canvas.toBlob([m
         (blob) => {[m
           if (blob) {[m
             // Create a File from the blob with the same name as the pdf[m
             const originalName = file.name.replace(/\.pdf$/i, "");[m
[31m-            const imageFile = new File([blob], `${originalName}.png`, {[m
[31m-              type: "image/png",[m
[32m+[m[32m            const ext = supportsWebP ? '.webp' : '.png';[m
[32m+[m[32m            const imageFile = new File([blob], `${originalName}${ext}`, {[m
[32m+[m[32m              type: format,[m
             });[m
 [m
[32m+[m[32m            const duration = performance.now() - startTime;[m
[32m+[m[32m            console.log(`PDF conversion took ${duration.toFixed(2)}ms`);[m
[32m+[m
             resolve({[m
               imageUrl: URL.createObjectURL(blob),[m
               file: imageFile,[m
[36m@@ -77,9 +108,9 @@[m [mexport async function convertPdfToImage([m
             });[m
           }[m
         },[m
[31m-        "image/png",[m
[31m-        1.0,[m
[31m-      ); // Set quality to maximum (1.0)[m
[32m+[m[32m        format,[m
[32m+[m[32m        quality,[m
[32m+[m[32m      );[m
     });[m
   } catch (err) {[m
     return {[m
[1mdiff --git a/app/lib/puter.ts b/app/lib/puter.ts[m
[1mindex b095dd3..72755ce 100644[m
[1m--- a/app/lib/puter.ts[m
[1m+++ b/app/lib/puter.ts[m
[36m@@ -257,20 +257,26 @@[m [mexport const usePuterStore = create<PuterStore>((set, get) => {[m
       return;[m
     }[m
 [m
[31m-    const interval = setInterval(() => {[m
[32m+[m[32m    // Use exponential backoff to reduce polling checks from 100 to ~10-15[m
[32m+[m[32m    let delay = 100;[m
[32m+[m[32m    let totalWait = 0;[m
[32m+[m[41m    [m
[32m+[m[32m    const checkPuter = () => {[m
       if (getPuter()) {[m
[31m-        clearInterval(interval);[m
         set({ puterReady: true });[m
         checkAuthStatus();[m
[31m-      }[m
[31m-    }, 100);[m
[31m-[m
[31m-    setTimeout(() => {[m
[31m-      clearInterval(interval);[m
[31m-      if (!getPuter()) {[m
[32m+[m[32m      } else if (totalWait < 10000) {[m
[32m+[m[32m        setTimeout(() => {[m
[32m+[m[32m          totalWait += delay;[m
[32m+[m[32m          delay = Math.min(delay * 2, 2000);[m
[32m+[m[32m          checkPuter();[m
[32m+[m[32m        }, delay);[m
[32m+[m[32m      } else {[m
         setError("Puter.js failed to load within 10 seconds");[m
       }[m
[31m-    }, 10000);[m
[32m+[m[32m    };[m
[32m+[m[41m    [m
[32m+[m[32m    checkPuter();[m
   };[m
 [m
   const write = async (path: string, data: string | File | Blob) => {[m
[36m@@ -297,7 +303,10 @@[m [mexport const usePuterStore = create<PuterStore>((set, get) => {[m
       setError("Puter.js not available");[m
       return;[m
     }[m
[31m-    return puter.fs.read(path);[m
[32m+[m[32m    const startTime = performance.now();[m
[32m+[m[32m    const result = await puter.fs.read(path);[m
[32m+[m[32m    console.log(`FS read ${path} took ${(performance.now() - startTime).toFixed(2)}ms`);[m
[32m+[m[32m    return result;[m
   };[m
 [m
   const upload = async (files: File[] | Blob[]) => {[m
[1mdiff --git a/app/lib/utils.ts b/app/lib/utils.ts[m
[1mindex cb94690..a268137 100644[m
[1m--- a/app/lib/utils.ts[m
[1m+++ b/app/lib/utils.ts[m
[36m@@ -35,3 +35,27 @@[m [mexport const formatSize = (bytes: number): string => {[m
  * generateUUID() // "550e8400-e29b-41d4-a716-446655440000"[m
  */[m
 export const generateUUID = () => crypto.randomUUID();[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Creates a debounced function that delays invoking func until after wait milliseconds[m
[32m+[m[32m * have elapsed since the last time the debounced function was invoked.[m
[32m+[m[32m *[m
[32m+[m[32m * @param fn - The function to debounce[m
[32m+[m[32m * @param delay - The number of milliseconds to delay[m
[32m+[m[32m * @returns The debounced function[m
[32m+[m[32m *[m
[32m+[m[32m * @example[m
[32m+[m[32m * const debouncedSearch = debounce((query) => search(query), 300);[m
[32m+[m[32m * debouncedSearch('hello'); // Called once after 300ms of no calls[m
[32m+[m[32m */[m
[32m+[m[32mexport function debounce<T extends (...args: any[]) => any>([m
[32m+[m[32m  fn: T,[m
[32m+[m[32m  delay: number[m
[32m+[m[32m): (...args: Parameters<T>) => void {[m
[32m+[m[32m  let timeoutId: ReturnType<typeof setTimeout> | undefined;[m
[32m+[m[41m  [m
[32m+[m[32m  return function(this: any, ...args: Parameters<T>) {[m
[32m+[m[32m    clearTimeout(timeoutId);[m
[32m+[m[32m    timeoutId = setTimeout(() => fn.apply(this, args), delay);[m
[32m+[m[32m  };[m
[32m+[m[32m}[m
\ No newline at end of file[m
[1mdiff --git a/app/routes/resume.tsx b/app/routes/resume.tsx[m
[1mindex 12a01ef..da7001f 100644[m
[1m--- a/app/routes/resume.tsx[m
[1m+++ b/app/routes/resume.tsx[m
[36m@@ -68,20 +68,26 @@[m [mconst Resume = () => {[m
           jobTitle: data.jobTitle || undefined,[m
         });[m
 [m
[31m-        if (data.resumePath) {[m
[31m-          const resumeBlob = await fs.read(data.resumePath);[m
[31m-          if (resumeBlob) {[m
[31m-            const pdfBlob = new Blob([resumeBlob], { type: "application/pdf" });[m
[32m+[m[32m        // Parallelize file reads for better performance[m
[32m+[m[32m        if (data.resumePath || data.imagePath) {[m
[32m+[m[32m          const [resumeResult, imageResult] = await Promise.allSettled([[m
[32m+[m[32m            data.resumePath ? fs.read(data.resumePath) : Promise.resolve(null),[m
[32m+[m[32m            data.imagePath ? fs.read(data.imagePath) : Promise.resolve(null),[m
[32m+[m[32m          ]);[m
[32m+[m
[32m+[m[32m          if (resumeResult.status === 'fulfilled' && resumeResult.value) {[m
[32m+[m[32m            const pdfBlob = new Blob([resumeResult.value], { type: "application/pdf" });[m
             const resumeObjectUrl = URL.createObjectURL(pdfBlob);[m
             setResumeUrl(resumeObjectUrl);[m
[32m+[m[32m          } else if (resumeResult.status === 'rejected') {[m
[32m+[m[32m            console.error('Failed to load resume PDF:', resumeResult.reason);[m
           }[m
[31m-        }[m
 [m
[31m-        if (data.imagePath) {[m
[31m-          const imageBlob = await fs.read(data.imagePath);[m
[31m-          if (imageBlob) {[m
[31m-            const imageObjectUrl = URL.createObjectURL(imageBlob);[m
[32m+[m[32m          if (imageResult.status === 'fulfilled' && imageResult.value) {[m
[32m+[m[32m            const imageObjectUrl = URL.createObjectURL(imageResult.value);[m
             setImageUrl(imageObjectUrl);[m
[32m+[m[32m          } else if (imageResult.status === 'rejected') {[m
[32m+[m[32m            console.error('Failed to load resume image:', imageResult.reason);[m
           }[m
         }[m
 [m
[36m@@ -96,6 +102,26 @@[m [mconst Resume = () => {[m
     loadResume();[m
   }, [id]);[m
 [m
[32m+[m[32m  // Cleanup URLs on unmount[m
[32m+[m[32m  useEffect(() => {[m
[32m+[m[32m    return () => {[m
[32m+[m[32m      if (imageUrl) {[m
[32m+[m[32m        try {[m
[32m+[m[32m          URL.revokeObjectURL(imageUrl);[m
[32m+[m[32m        } catch (e) {[m
[32m+[m[32m          // Ignore errors from already-revoked URLs[m
[32m+[m[32m        }[m
[32m+[m[32m      }[m
[32m+[m[32m      if (resumeUrl) {[m
[32m+[m[32m        try {[m
[32m+[m[32m          URL.revokeObjectURL(resumeUrl);[m
[32m+[m[32m        } catch (e) {[m
[32m+[m[32m          // Ignore errors from already-revoked URLs[m
[32m+[m[32m        }[m
[32m+[m[32m      }[m
[32m+[m[32m    };[m
[32m+[m[32m  }, [imageUrl, resumeUrl]);[m
[32m+[m
   return ([m
     <main className="relative overflow-hidden">[m
       <Navbar />[m
